// grafo.h

#ifndef GRAFO_H
#define GRAFO_H

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

#define MAX_VIZINHOS 4
#define MAX_NOME_RUA 50

typedef struct {
    char id;
    float x, y;
    char rua1[MAX_NOME_RUA];
    char rua2[MAX_NOME_RUA];
} Ponto;

typedef struct {
    char origem;
    char destino;
    char nomeRua[MAX_NOME_RUA];
    float distancia;
} Aresta;

typedef struct {
    int numPontos;
    int numArestas;
    Ponto* pontos;
    Aresta* arestas;
} Grafo;



// Funções para realizar a manipulação do grafo
Grafo* inicializa_grafo(const char* pontosBin, const char* vizinhosBin) 
{
    Grafo* grafo = (Grafo*)malloc(sizeof(Grafo));
    if (!grafo) {
        printf("Erro ao alocar memória para o grafo.\n");
        exit(1);
    }

    // Abrir e ler o arquivo de pontos binário
    FILE* filePontos = fopen(pontosBin, "rb");
    if (!filePontos) {
        printf("Erro ao abrir o arquivo binário de pontos.\n");
        exit(1);
    }
    fread(&grafo->numPontos, sizeof(int), 1, filePontos);
    grafo->pontos = (Ponto*)malloc(grafo->numPontos * sizeof(Ponto));
    fread(grafo->pontos, sizeof(Ponto), grafo->numPontos, filePontos);
    fclose(filePontos);

    // Abrir e ler o arquivo de vizinhos binário
    FILE* fileVizinhos = fopen(vizinhosBin, "rb");
    if (!fileVizinhos) {
        printf("Erro ao abrir o arquivo binário de vizinhos.\n");
        exit(1);
    }
    fread(&grafo->numArestas, sizeof(int), 1, fileVizinhos);
    grafo->arestas = (Aresta*)malloc(grafo->numArestas * sizeof(Aresta));
    fread(grafo->arestas, sizeof(Aresta), grafo->numArestas, fileVizinhos);
    fclose(fileVizinhos);

    return grafo;
}



void insere_arestas(Grafo* grafo) 
{
    for (int i = 0; i < grafo->numArestas; i++) {
        Aresta* aresta = &grafo->arestas[i];
        Ponto* origem = NULL;
        Ponto* destino = NULL;

        // Localizar os pontos de origem e destino da aresta
        for (int j = 0; j < grafo->numPontos; j++) {
            if (grafo->pontos[j].id == aresta->origem) {
                origem = &grafo->pontos[j];
            }
            if (grafo->pontos[j].id == aresta->destino) {
                destino = &grafo->pontos[j];
            }
        }

        // Calcular a distância e atribuir
        if (origem && destino) {
            aresta->distancia = sqrt(pow(destino->x - origem->x, 2) + pow(destino->y - origem->y, 2));
        } else {
            printf("Erro: Não foi possível encontrar os pontos da aresta %c -> %c.\n", aresta->origem, aresta->destino);
        }
    }
}




void dijkstra(Grafo* grafo, char origem, char destino) 
{
    int numPontos = grafo->numPontos;
    // Alocação dinâmica dos arrays
    float* dist = (float*)malloc(numPontos * sizeof(float));
    char* anterior = (char*)malloc(numPontos * sizeof(char));
    int* visitado = (int*)malloc(numPontos * sizeof(int));
    char* ids = (char*)malloc(numPontos * sizeof(char));

    // Inicializar arrays
    for (int i = 0; i < numPontos; i++) {
        dist[i] = INFINITY;
        anterior[i] = '\0';
        visitado[i] = 0;
        ids[i] = grafo->pontos[i].id;
        if (grafo->pontos[i].id == origem) {
            dist[i] = 0;
        }
    }

    // Implementação do Dijkstra
    for (int i = 0; i < numPontos; i++) {
        // Encontrar o nó não visitado com menor distância
        int u = -1;
        for (int j = 0; j < numPontos; j++) {
            if (!visitado[j] && (u == -1 || dist[j] < dist[u])) {
                u = j;
            }
        }

        // Marcar como visitado
        visitado[u] = 1;

        // Atualizar as distâncias dos vizinhos
        for (int j = 0; j < grafo->numArestas; j++) {
            Aresta* aresta = &grafo->arestas[j];
            if (aresta->origem == ids[u]) {
                for (int k = 0; k < numPontos; k++) {
                    if (ids[k] == aresta->destino) {
                        float novaDist = dist[u] + aresta->distancia;
                        if (novaDist < dist[k]) {
                            dist[k] = novaDist;
                            anterior[k] = ids[u];
                        }
                    }
                }
            }
        }
    }

    // Mostrar o menor caminho
    printf("Menor caminho de %c para %c:\n", origem, destino);

    char* caminho = (char*)malloc(numPontos * sizeof(char));
    if (!caminho) {
        printf("Erro ao alocar memória para o caminho.\n");
        free(dist);    // Liberando os arrays alocados previamente em caso de erro
        free(anterior);
        free(visitado);
        free(ids);
        exit(1);
    }
    int index = 0;
    for (char atual = destino; atual != '\0'; atual = anterior[atual - 'A']) {
        caminho[index++] = atual;
    }
    for (int i = index - 1; i >= 0; i--) {
        printf("%c ", caminho[i]);
    }
    printf("\nDistância total: %.2f\n", dist[destino - 'A']);
}




void gerar_relatorio(Grafo* grafo, char origem, char destino, const char* arquivoRelatorio, char anterior[]) {
    FILE* arquivo = fopen(arquivoRelatorio, "w");
    if (!arquivo) {
        printf("Erro ao criar o arquivo de relatório.\n");
        return;
    }

    fprintf(arquivo, "Relatório do menor caminho\n");
    fprintf(arquivo, "Origem: %c\n", origem);
    fprintf(arquivo, "Destino: %c\n", destino);
    fprintf(arquivo, "Caminho:\n");

    // Alocação dinâmica para o array caminho
    char* caminho = (char*)malloc(grafo->numPontos * sizeof(char));
    if (!caminho) {
        fprintf(stderr, "Erro ao alocar memória para o caminho.\n");
        fclose(arquivo);
        return;
    }

    int index = 0;
    
    // Traça o caminho do destino até a origem
    for (char atual = destino; atual != origem; atual = anterior[atual - 'A']) {
        caminho[index++] = atual;
    }
    caminho[index++] = origem;  // Adiciona o ponto de origem no final do caminho

    // Imprime o caminho no relatório em ordem correta (da origem ao destino)
    for (int i = index - 1; i > 0; i--) {
        char atual = caminho[i];
        char prox = caminho[i - 1];

        for (int j = 0; j < grafo->numArestas; j++) {
            if (grafo->arestas[j].origem == atual && grafo->arestas[j].destino == prox) {
                fprintf(arquivo, "Siga pela rua %s até o cruzamento com %s.\n",
                        grafo->arestas[j].nomeRua, grafo->pontos[prox - 'A'].rua1);
                break;
            }
        }
    }

    fprintf(arquivo, "Fim do percurso.\n");
    
    // Libera a memória alocada para o caminho
    free(caminho);
    fclose(arquivo);
}


#endif
